@using System.Diagnostics.CodeAnalysis
@typeparam T

@inherits InputBase<T>

<div class="date">
    @if (!string.IsNullOrEmpty(this.Label))
    {
        <div class="Date_Label">
            <label>@this.Label</label>
        </div>
    }
    <div class="date_inputs">
        <SelectInput Class="@this.BtnClass" readonly @bind-Value:after=OnValueChanged @bind-Value=HourValue Placeholder="Hora" DataSet="TimeInputEnums.GetHoursList()" />
        <span>:</span>
        <SelectInput Class="@this.BtnClass" ReadOnly @bind-Value:after=OnValueChanged @bind-Value=MinuteValue Placeholder="Minuto" DataSet="TimeInputEnums.GetMinutes()" />
    </div>
</div>

@code {
    [Parameter] public string? Label { get; set; }
    [Parameter] public string? BtnClass { get; set; } = string.Empty;
    bool _valuesAreNull => string.IsNullOrWhiteSpace(HourValue) && string.IsNullOrWhiteSpace(MinuteValue);

    public string? HourValue { get; set; }
    public string? MinuteValue { get; set; }

    protected override Task OnInitializedAsync()
    {

        if (Value != null)
        {
            var val = (TimeOnly)(object)Value;
            this.HourValue = val.Hour.ToString();
            this.MinuteValue = val.Minute.ToString();
        }
        return base.OnInitializedAsync();
    }

    async Task OnValueChanged()
    {
        var parsedSuccess = TimeOnly.TryParse($"{HourValue}:{MinuteValue}", out var parsedValue);
        if (parsedSuccess)
        {
            this.Value = (T)(object)parsedValue;
        }
        else
        {
            this.Value = default;
        }
        await ValueChanged.InvokeAsync(this.Value);
    }

    protected override bool TryParseValueFromString(string? value, [MaybeNullWhen(false)] out T result, [NotNullWhen(false)] out string validationErrorMessage)
    {
        try
        {
            // Inicializar as saídas
            result = default!;
            validationErrorMessage = null!;

            // Implementar a lógica de conversão aqui
            if (typeof(T) == typeof(TimeOnly) || typeof(T) == typeof(TimeOnly?))
            {
                // Se T for string, simplesmente atribuímos o valor
                result = (T)(object)value;
                return result is null ? false : true;
            }
            else
            {
                // Lidar com outros tipos conforme necessário
                // Exemplo: DateTime, bool, etc.
                // Implemente as conversões para outros tipos aqui
            }

            // Se nenhum dos tipos correspondentes for encontrado, retornar false
            validationErrorMessage = $"Failed to parse {typeof(T).Name} from '{value}'.";
            return false;
        }
        catch (Exception ex)
        {
            // Se ocorrer uma exceção durante a conversão, capturar e retornar a mensagem de erro
            result = default!;
            validationErrorMessage = ex.Message;
            return false;
        }
    }
}